\section{Type-Agnostic Optimization}
\label{sec:templated_optimize}

% We can start by expanding on the linear regression function example to point
% out that we may want different types.

\begin{figure}[b!]
\hrule
\vspace{1ex}
\begin{minted}{c++}
class GradientDescent
{
  template<typename FunctionType, typename MatType, typename GradType = MatType>
  typename MatType::elem_type Optimize(FunctionType& function, MatType& coordinates)
  {
    // The step size is hardcoded to 0.01, and the number of iterations is 1000.
    for (size_t i = 0; i < 1000; ++i)
    {
      GradType gradient;
      function.Gradient(coordinates, gradient);

      // Take the step.
      coordinates -= 0.01 * gradient;
    }

    // Compute and return the final objective.
    return function.Evaluate(coordinates);
  }
};
\end{minted}
\hrule
\vspace*{-0.5em}
\caption{Example implementation of a simple gradient descent optimizer.
For the sake of brevity, functionality such as the ability to configure the parameters has
been deliberately omitted.
The actual {\tt GradientDescent} optimizer {\tt ensmallen} provides more functionality.
}

\label{fig:gd}
\end{figure}

In the example shown in Section~\ref{sec:linreg_example},
where we introduced the class {\tt LinearRegressionFunction},
the matrix and vector objects are hardcoded as {\tt arma::mat} and {\tt arma::vec}.
These objects hold elements with the C++ type {\tt double},
representing double precision floating point.
However, in many applications it can be very important to specify a different
underlying element type.  For instance, in the field of machine learning, neural
networks have been shown to be effective with low-precision floating point
representations for weights~\cite{vanhoucke2011improving}.
%% low-precision integers~\cite{courbariaux2015training},
%% or even single bits~\cite{courbariaux2015binaryconnect}.
Furthermore, many optimization problems have parameters
that are best represented as sparse data~\cite{van2011sparse, recht2011hogwild},
which is represented in Armadillo as the {\tt sp\_mat} class~\cite{sanderson2018user, mca24030070}.
Even alternate representations such as data held on the GPU can be quite
important: the use of GPUs can often result in significant
speedups~\cite{oh2004gpu, athanasopoulos2011gpu}.

In order to handle this diverse set of needs, {\tt ensmallen} has been built in
such a way that any underlying storage type can be used to represent the
coordinates to be optimized---so long as it matches the Armadillo API.
This means that the Bandicoot GPU matrix library\footnote{\url{https://gitlab.com/conradsnicta/bandicoot-code}}
can be used as a drop-in replacement once it is stable.

Consider the simplified gradient descent optimizer shown in Figure~\ref{fig:gd}.
The use of the template types {\tt FunctionType}, {\tt MatType}, and {\tt
GradType} means that at compilation time, the correct types are substituted in
for {\tt FunctionType}, {\tt MatType}, and {\tt GradType} (which by default is
set to be the same as {\tt MatType} in this code).  So long as each type has all
the methods that are used inside of {\tt Optimize()}, there will be no
compilation problems.  Templates are a technique for code generation; in this
case, that means the code generated will be exactly the same as if {\tt
Optimize()} was written with the types specified in those template parameters.
This means that there is no additional runtime overhead when a different {\tt
MatType} is used.

% TODO: this to a later details section?

However, there is one important drawback of C++ that we must work around when
providing support for any {\tt MatType}, and that is the issue of compiler
errors.  The compiler may fail to substitute a given {\tt MatType} into the
code above for {\tt GradientDescent::Optimize()}; a typical reason might be that
some needed method of {\tt MatType} or {\tt FunctionType} is not available.
For example, the given {\tt MatType} does not have an {\tt operator\*()} method.
When this happens, most current C++ compilers will emit a very long list
of error messages, with all relevant information about the attempted
template instantions.
This onslaught of error messages can be confusing and discouraging to users.
{\tt ensmallen} avoids this issue via the use of C++ compile-time static
assertions ({\tt static\_assert()}).
Users who are interested in the details of how these assertions work should
refer to Section~\ref{sec:templated_optimize_details}.

Note that users who would like to continue despite these {\tt static\_assert()}
checks failing may simply define the macro {\tt ENS\_DISABLE\_TYPE\_CHECKS} in
their code before the line {\tt \#include <ensmallen.hpp>}.

