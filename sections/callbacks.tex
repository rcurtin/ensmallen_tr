\section{Callbacks}
\label{sec:callbacks}

Many optimizers offer the ability to modify the optimization process. Examples
include changing the step size, adding custom constraints when they are violated
by the current solution, or providing custom heuristics to find and investigate
feasible solutions.

In the past this functionality was limited to solver-specific interfaces [], in
contrast, ensmallen provides, optimizer independent callbacks to allow guidance
of the optimization process and to monitor the behavior of optimizers. In
particular, ensmallen's callbacks allow code to be executed regularly during an
optimization session. To use callbacks, either for optimization, tuning or
logging, a user can pass arbitrary callbacks to any optimizer in the Optimize()
function:

\begin{minted}{c++}
RosenbrockFunction f;
arma::mat coordinates = f.GetInitialPoint();

MomentumSGD optimizer(0.01, 32, 100000, 1e-5, true, MomentumUpdate(0.5));
optimizer.Optimize(f, coordinates, EarlyStopAtMinLoss(), ProgressBar());
\end{minted}

Given the pre-defined callbacks {\tt EarlyStopAtMinLoss()} and {\tt
ProgressBar()} the code snippet above shows not only how the Momentum-SGD
optimizer can be used to find the best coordinates but also how the callbacks
can be used to control and overview the optimization process by calling the
callbacks at different stages of the optimization process.

There are eight types of optimization callback routines that are regularly
called during the optimization process (depending on the function type).
Table~\ref{tab:callback_list} lists the available types.

\begin{table}[H]
\centering
\small
\begin{tabular}{lll}
\toprule
{\bf Function} & {\bf Description} & {\bf Function type} \\
\hline
\texttt{BeginOptimization}   & Called at the beginning of the optimization process  & all \\
\texttt{EndOptimization}     & Called at the end of the optimization process        & all \\
\texttt{Evaluate}            & Called after any call to {\it Evaluate()}            & Arbitrary, Differentiable, Partially differentiable,  \\
                             &                                                      & Arbitrary separable, Differentiable separable \\
\texttt{EvaluateConstraint}  & Called after any call to {\it EvaluateConstraint()}  & Constrained \\
\texttt{Gradient}            & Called after any call to {\it Gradient()}            & Differentiable, Partially differentiable \\
                             &                                                      & Differentiable separable \\
\texttt{GradientConstraint}  & Called after any call to {\it GradientConstraint()}  & Constrained \\
\texttt{BeginEpoch}          & Called at the beginning of a pass over the data      & Differentiable separable \\
\texttt{EndEpoch}            & Called at the end of a pass over the data            & Differentiable separable \\

\bottomrule
\end{tabular}
\vspace{0.5ex}
\caption
  {
  Available callback routines, with brief descriptions.
  Optional additional arguments have been omitted for brevity.
  See {\href{http://www.ensmallen.org/docs.html}{\mbox{\tt http://www.ensmallen.org/docs.html}}} for more detailed documentation.
  }
\label{tab:callback_list}
\end{table}

Callbacks are executed in the order that they are specified, by default
subsequent callbacks are discared if a callback terminates the optimization
process under circumstances defined by the application. To terminate the
optimiation process via callbacks, each callback routine can return an boolean,
true to continue, or false to indicate that the optimization process should be
terminated.

\begin{minted}{c++}
class CustomCallback
{
  template<typename OptimizerType, typename FunctionType, typename MatType>
  bool Evaluate(OptimizerType& optimizer,
                FunctionType& function,
                const MatType& coordinates,
                const double objective)
  {
    return true;  // Continue the optimization process.
  }
};
\end{minted}

If your callback requires additional parameters beyond what is passed through
the predefined arguments, a user is encouraged to manully instantiate an object
with them, and pass the object or access optimizer specific parameter via the
optimizer interface. ensmallen does not modify or dereference the object, so it
is safe to use for this purpose.

\begin{minted}{c++}
struct CustomCallback
{
  CustomCallback(double rIn) : p(rIn) {}

  template<typename OptimizerType, typename FunctionType, typename MatType>
    void StepTaken(OptimizerType& optimizer,
                   FunctionType& function,
                   MatType& coordinates)
    {
      optimizer.StepSize() *= r;
    }

  double r;
};

RosenbrockFunction f;
arma::mat coordinates = f.GetInitialPoint();

Adam opt;
CustomCallback cb(0.9);
opt.Optimize(f, coordinates, cb);
\end{minted}

In this example, we pass an instatiated custom callback that takes an additional
step size decay parameter as input, in addition, inside the StepTake() callback
we use the optimizer interface ({\tt StepSize()}) to update the step size.

Please see a complete list and description of ensmallens's callback functions in
the callback documentation. In addition, we recommend closely reviewing the
examples provided in
\url{include/ensmallen_bits/callbacks}
which provide examples of how to use most of these callback functions.




\begin{figure}[!tb]
\centering
\hrule
\hrule
\vspace{0.5ex}
\begin{minipage}{0.45\textwidth}
\begin{minted}[fontsize=\footnotesize,stripnl=false]{c++}
struct Optimizer
{
  template<typename FT>
  void Optimize(FT& f, arma::mat& p)
  {
    f.Evaluate(p);
  }
};

void main()
{
  RosenbrockFunction rf;
  arma::mat parameters = rf.GetInitialPoint();
  Optimizer opt;
  opt.Optimize(rf, parameters);
}

\end{minted}
\end{minipage}
%
\hfill
\vline
\vline
\hfill
%
\begin{minipage}{0.45\textwidth}
\begin{minted}[escapeinside=||,fontsize=\footnotesize]{c++}
struct Optimizer
{
  template<typename FT, |\colorbox{yellow}{typename... CT}|>
  void Optimize(FT& f, arma::mat& p, CT&&... c)
  {
    |\colorbox{yellow}{Callback::BeginOptimization(*this, f, p, c...);}|
    f.Evaluate(iterate);
  }
};
void main()
{
  RosenbrockFunction rf;
  arma::mat parameters = rf.GetInitialPoint();
  Optimizer opt;
  opt.Optimize(rf, parameters);
}
\end{minted}
\end{minipage}
\vspace{0.5ex}
\hrule
\hrule
\caption
  {
  Left panel: A C++ program that mimics the ensmallen optimizer interface
  without any callback functionality. Right panel: A corresponding C++ program
  using an empty callback routine that is automatically optimized out. Both
  programs produce the exact same assembler output, resulting in no performance
  penalty if no callbacks are used.
  }
\label{fig:manual_vs_automatic_conversion}
\end{figure}





A custom callback is a powerful tool to customize the behavior of a function
during the optimization process. Examples include {\tt StoreBestCoordinates<>()}
where the model is automatically saved during the optimization process or {\tt
EarlyStoppingAtMinLoss()}  which stops the optimization process when the minimum
of loss has been reached.

\begin{minted}{c++}
class EarlyStoppingAtMinLoss
{
 public:
  // Set up the early stopping at min loss class, which keeps track of the
  // minimum loss.
  EarlyStop() : bestObjective(std::numeric_limits<double>::max()) { }

  // Callback function called at the end of a pass over the data, which provides
  // the current objective. We are only interested in the objective and ignore
  // the rest.
  template<typename OptimizerType, typename FunctionType, typename MatType>
  void EndEpoch(OptimizerType&, FunctionType&, const MatType&, const size_t,
                const double objective)
  {
    // Check if the given objective is lower as the previous objective.
    if (objective < bestObjective)
    {
      bestObjective = objective; // Update the local objective.
    }
    else
    {
      return true; // Stop the optimization process.
    }

    return false; // Do not stop the optimization process.
  }

  double bestObjective;
};
\end{minted}


\begin{minted}{c++}
// We assume that "X" and "y" are given.
LinearRegressionFunction f(X, y);

L_BFGS optimizer; // Create the optimizer with all default parameters.

// The theta_best matrix will hold the best model that we find after we call
// Optimize(); for now, we set it to the initial point (uniform random values).
arma::mat theta_best(X.n_rows, 1, arma::fill:randu);

// Optimize the given function and provide a callback (EarlyStoppingAtMinLoss)
// that is called at the end of an epoch.
optimizer.Optimize(f, theta_best, EarlyStoppingAtMinLoss());
\end{minted}
