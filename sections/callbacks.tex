\section{Callbacks}
\label{sec:callbacks}

Many optimizers offer the ability to modify the optimization process. Examples
include changing the step size, adding custom constraints when they are violated
by the current solution, or providing custom heuristics to find and investigate
feasible solutions.

In the past this functionality was limited to solver-specific interfaces [], in
contrast, ensmallen provides, optimizer independent callbacks to allow guidance
of the optimization process and to monitor the behavior of optimization. In
particular, ensmallen's callbacks allow code to be executed regularly during an
optimization session. To use callbacks, either for optimization, tuning or
logging, a user can pass arbitrary callbacks to any optimizer in the Optimize()
function. Figure~\ref{fig:example_prog_callbacks} contains a simple C++ program which briefly demonstrates usage of the callback functionaility.

\begin{figure}[H]
\centering
\hrule
\vspace{1ex}
\begin{adjustbox}{minipage=\columnwidth,scale={0.90}{0.85}}
\begin{minted}{c++}
RosenbrockFunction f;
arma::mat coordinates = f.GetInitialPoint();

MomentumSGD optimizer(0.01, 32, 100000, 1e-5, true, MomentumUpdate(0.5));
optimizer.Optimize(f, coordinates, EarlyStopAtMinLoss(), ProgressBar());
\end{minted}
\end{adjustbox}
\vspace{1ex}
\hrule
\caption
  {
  A simple C++ program to demonstrate usage of the callback functionality using pre-defined callbacks: \texttt{EarlyStopAtMinLoss()} and \texttt{ProgressBar}.
  }
\label{fig:example_prog_callbacks}
\end{figure}

Given the pre-defined callbacks {\tt EarlyStopAtMinLoss()} and {\tt
ProgressBar()} the code snippet above shows not only how the Momentum-SGD
optimizer can be used to find the best coordinates but also how the callbacks
can be used to control and overview the optimization process by calling the
callbacks at different stages of the optimization process.\newline

There are eight types of optimization callback routines that are regularly
called during the optimization process (depending on the function type).
Table~\ref{tab:callback_list} lists the available types.

\begin{table}[H]
\centering
\small
\begin{tabular}{lll}
\toprule
{\bf Function} & {\bf Description} & {\bf Function type} \\
\hline
\texttt{BeginOptimization}   & Called at the beginning of the optimization process  & all \\
\texttt{EndOptimization}     & Called at the end of the optimization process        & all \\
\texttt{Evaluate}            & Called after any call to {\it Evaluate()}            & Arbitrary, Differentiable, Partially differentiable,  \\
                             &                                                      & Arbitrary separable, Differentiable separable \\
\texttt{EvaluateConstraint}  & Called after any call to {\it EvaluateConstraint()}  & Constrained \\
\texttt{Gradient}            & Called after any call to {\it Gradient()}            & Differentiable, Partially differentiable \\
                             &                                                      & Differentiable separable \\
\texttt{GradientConstraint}  & Called after any call to {\it GradientConstraint()}  & Constrained \\
\texttt{BeginEpoch}          & Called at the beginning of a pass over the data      & Differentiable separable \\
\texttt{EndEpoch}            & Called at the end of a pass over the data            & Differentiable separable \\

\bottomrule
\end{tabular}
\vspace{0.5ex}
\caption
  {
  Available callback routines, with brief descriptions.
  Optional additional arguments have been omitted for brevity.
  See {\href{http://www.ensmallen.org/docs.html}{\mbox{\tt http://www.ensmallen.org/docs.html}}} for more detailed documentation.
  }
\label{tab:callback_list}
\end{table}

Callbacks are executed in the order that they are specified, by default
subsequent callbacks are discared if a callback terminates the optimization
process under circumstances defined by the application. To terminate the
optimiation process via callbacks, each callback routine can return an boolean,
true to continue, or false to indicate that the optimization process should be
terminated.

\begin{figure}[H]
\centering
\hrule
\vspace{1ex}
\begin{adjustbox}{minipage=\columnwidth,scale={0.90}{0.85}}
\begin{minted}{c++}
class CustomCallback
{
  template<typename OptimizerType, typename FunctionType, typename MatType>
  bool Evaluate(OptimizerType& optimizer,
                FunctionType& function,
                const MatType& coordinates,
                const double objective)
  {
    return true;  // Continue the optimization process.
  }
};
\end{minted}
\end{adjustbox}
\vspace{1ex}
\hrule
\caption
  {
  Control the optimization process via the return value of the callback routine.
  }
\label{fig:example_prog_callbacks}
\end{figure}

If a callback requires additional parameters beyond what is passed through
the predefined arguments, a user is encouraged to manully instantiate an object
with them, and pass the object or access optimizer specific parameter via the
optimizer interface. ensmallen does not modify or dereference the object, so it
is safe to use for this purpose.

\begin{figure}[H]
\centering
\hrule
\vspace{1ex}
\begin{adjustbox}{minipage=\columnwidth,scale={0.90}{0.85}}
\begin{minted}{c++}
struct CustomCallback
{
  CustomCallback(double rIn) : p(rIn) {}

  template<typename OptimizerType, typename FunctionType, typename MatType>
    void StepTaken(OptimizerType& optimizer,
                   FunctionType& function,
                   MatType& coordinates)
    {
      optimizer.StepSize() *= r;
    }

  double r;
};

RosenbrockFunction f;
arma::mat coordinates = f.GetInitialPoint();

Adam opt;
CustomCallback cb(0.9);
opt.Optimize(f, coordinates, cb);
\end{minted}
\end{adjustbox}
\vspace{1ex}
\hrule
\caption
  {
  A simple C++ program of adding additional parameter to a Callback and accessing optimizer specific parameter.
  }
\label{fig:example_prog_callbacks_parameter}
\end{figure}

In this example~\ref{fig:example_prog_callbacks_parameter}, we pass an
instatiated custom callback that takes an additional step-size decay parameter
as input, in addition, inside the {\tt StepTake()} callback we use the optimizer
interface ({\tt StepSize()}) to update the step size.

To demonstrate the advantages of the template-based optimization mechanism, we
performed a set of experiments~\ref{fig:callback_compilter_opt}, that compared
the machine code of an optimizer with callback support and without. In all
cases, a modern C++ compiler [] optimized away the non-used code, the resultant
machine code appears as if the never existed in the first place.

\begin{figure}[H]
\centering
\hrule
\hrule
\vspace{0.5ex}
\begin{minipage}{0.45\textwidth}
\begin{minted}[fontsize=\footnotesize,stripnl=false]{c++}
struct Optimizer
{
  template<typename FT>
  void Optimize(FT& f, arma::mat& p)
  {
    f.Evaluate(p);
  }
};

void main()
{
  RosenbrockFunction rf;
  arma::mat parameters = rf.GetInitialPoint();
  Optimizer opt;
  opt.Optimize(rf, parameters);
}

\end{minted}
\end{minipage}
%
\hfill
\vline
\vline
\hfill
%
\begin{minipage}{0.45\textwidth}
\begin{minted}[escapeinside=||,fontsize=\footnotesize]{c++}
struct Optimizer
{
  template<typename FT, |\colorbox{yellow}{typename... CallbackType}|>
  void Optimize(FT& f, arma::mat& p, CallbackType&&... c)
  {
    |\colorbox{yellow}{Callback::BeginOptimization(*this, f, p, c...);}|
    f.Evaluate(iterate);
  }
};
void main()
{
  RosenbrockFunction rf;
  arma::mat parameters = rf.GetInitialPoint();
  Optimizer opt;
  opt.Optimize(rf, parameters);
}
\end{minted}
\end{minipage}
\vspace{0.5ex}
\hrule
\hrule
\caption
  {
  Left panel: A C++ program that mimics the ensmallen optimizer interface
  without any callback functionality. Right panel: A corresponding C++ program
  using an empty callback routine that is automatically optimized out. Both
  programs produce the exact same machine code, resulting in no performance
  penalty if no callbacks are used.
  }
\label{fig:callback_compilter_opt}
\end{figure}

For the sake of brevity we omit the expressions for the {\tt BeginOptimization}
method \footnote{Interested readers can find that code in {\tt
ensmallen\_bits/callbacks/callbacks.hpp}.}. The function depend heavily on
SFINAE techniques for method detection; {\tt HasBeginOptimization} will evaluate
to {\tt true} if {\tt CallbackType} has {\tt BeginOptimization()} and {\tt
false} otherwise.

Using the boolean template variable, we can then use template specialization to
control whether {\tt BeginOptimization} returns a boolean, void to control the
optimization process or if the callback ends in an empty function
call.











A custom callback is a powerful tool to customize the behavior of a function
during the optimization process. Examples include {\tt StoreBestCoordinates<>()}
where the model is automatically saved during the optimization process or {\tt
EarlyStoppingAtMinLoss()}  which stops the optimization process when the minimum
of loss has been reached.

\begin{figure}[H]
\centering
\hrule
\vspace{1ex}
\begin{adjustbox}{minipage=\columnwidth,scale={0.90}{0.85}}
\begin{minted}{c++}
class EarlyStoppingAtMinLoss
{
 public:
  // Set up the early stopping at min loss class, which keeps track of the
  // minimum loss.
  EarlyStop() : bestObjective(std::numeric_limits<double>::max()) { }

  // Callback function called at the end of a pass over the data, which provides
  // the current objective. We are only interested in the objective and ignore
  // the rest.
  template<typename OptimizerType, typename FunctionType, typename MatType>
  void EndEpoch(OptimizerType&, FunctionType&, const MatType&, const size_t,
                const double objective)
  {
    // Check if the given objective is lower as the previous objective.
    if (objective < bestObjective)
    {
      bestObjective = objective; // Update the local objective.
    }
    else
    {
      return true; // Stop the optimization process.
    }

    return false; // Do not stop the optimization process.
  }

  double bestObjective;
};
\end{minted}


\begin{minted}{c++}
// We assume that "X" and "y" are given.
LinearRegressionFunction f(X, y);

L_BFGS optimizer; // Create the optimizer with all default parameters.

// The theta_best matrix will hold the best model that we find after we call
// Optimize(); for now, we set it to the initial point (uniform random values).
arma::mat theta_best(X.n_rows, 1, arma::fill:randu);

// Optimize the given function and provide a callback (EarlyStoppingAtMinLoss)
// that is called at the end of an epoch.
optimizer.Optimize(f, theta_best, EarlyStoppingAtMinLoss());
\end{minted}
\end{adjustbox}
\vspace{1ex}
\hrule
\caption
  {
  A simple C++ program that demonstrates the implementation of a custom callback function.
  }
\label{fig:example_prog_callbacks_parameter}
\end{figure}

Please see a complete list and description of ensmallens's callback functions in
the callback documentation. In addition, we recommend closely reviewing the
examples provided in
\url{include/ensmallen_bits/callbacks}
which provide examples of how to use most of these callback functions.
